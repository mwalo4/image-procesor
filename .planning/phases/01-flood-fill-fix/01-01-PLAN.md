---
phase: 01-flood-fill-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - universal_processor.py
autonomous: false
requirements:
  - PROC-01
  - PROC-02

must_haves:
  truths:
    - "Natura Siberica test image processed in non-AI mode shows all 3 products with white areas intact"
    - "White product areas touching the image edge are NOT eaten by flood-fill"
    - "White product surfaces remain at original brightness (~255), visually distinct from #F3F3F3 (243) background"
    - "Standard images (dark/colorful products on white background) still process identically to before"
  artifacts:
    - path: "universal_processor.py"
      provides: "Improved _compute_background_mask_rgb with stronger edge barrier"
      contains: "_compute_background_mask_rgb"
  key_links:
    - from: "_compute_background_mask_rgb"
      to: "flood-fill BFS"
      via: "enhanced edge barrier that blocks flood-fill at product boundaries"
      pattern: "edge_barrier|saturation|morpholog"
---

<objective>
Strengthen the flood-fill edge barrier in `_compute_background_mask_rgb` so that white product areas touching the image edge are not consumed by the BFS flood-fill.

Purpose: White products (like Natura Siberica white boxes) currently get eaten by flood-fill because the gradient barrier alone doesn't catch subtle white-to-white transitions. This causes products to disappear or blend with the #F3F3F3 background.

Output: Updated `_compute_background_mask_rgb` method with multi-signal edge barrier (gradient + saturation/color analysis + morphological cleanup) that blocks flood-fill at product boundaries while remaining transparent for the 99% of images that already work.
</objective>

<execution_context>
@/Users/marek/.claude/get-shit-done/workflows/execute-plan.md
@/Users/marek/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-flood-fill-fix/1-CONTEXT.md
@universal_processor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Strengthen flood-fill edge barrier with multi-signal detection</name>
  <files>universal_processor.py</files>
  <action>
Modify `_compute_background_mask_rgb` (starts at line 160) to improve the flood-fill barrier. The fix goes into the section between line 214 (edge barrier comment) and line 224 (before BFS). All changes stay within this method, at the 256px downscaled resolution.

**Step 1 — Lower gradient barrier threshold:**
Change the default `edge_barrier_threshold` from 15 to 10 in `__init__` (line 56). At 256px resolution, gradients are smoother, so a lower threshold catches more subtle product edges. This alone helps but isn't sufficient.

**Step 2 — Pre-smooth before gradient computation:**
Before computing the gradient (lines 217-220), apply a small Gaussian blur (sigma ~1.0) to `mean_brightness` to reduce noise on uniform backgrounds that could create false barriers. Use `scipy.ndimage.gaussian_filter` or implement manually with a 3x3 kernel via NumPy convolution. If scipy is not available, use a simple box blur (uniform_filter). The goal: real product edges survive the blur, but pixel noise on flat backgrounds is suppressed.

**Step 3 — Add saturation-based barrier:**
After the gradient barrier block, add a saturation analysis. Product whites often have subtle color (slight yellow/blue tint from printing, packaging sheen) while studio background whites are near-neutral. Compute per-pixel saturation from the `arr` RGB array:
```python
max_rgb = np.max(arr[:, :, :3], axis=2).astype(np.float32)
min_rgb = np.min(arr[:, :, :3], axis=2).astype(np.float32)
saturation = np.where(max_rgb > 0, (max_rgb - min_rgb) / max_rgb, 0)
```
Pixels with saturation above a small threshold (e.g., 0.04-0.06) in bright regions (brightness > 200) are likely product, not background. Mark these as barriers:
```python
is_saturated_bright = (saturation > 0.05) & (mean_brightness > 200)
white_like = white_like & ~is_saturated_bright
```
This provides a second independent signal beyond gradient magnitude.

**Step 4 — Add local texture/variance barrier:**
Compute local variance in a small window (5x5 or 7x7) around each pixel. Background areas are uniform (low variance), while product areas have text, logos, textures (higher variance). Use a sliding window variance:
```python
from scipy.ndimage import uniform_filter
local_mean = uniform_filter(mean_brightness.astype(np.float64), size=5)
local_sqmean = uniform_filter((mean_brightness.astype(np.float64))**2, size=5)
local_var = local_sqmean - local_mean**2
is_textured = local_var > some_threshold  # e.g., 15-30
```
Mark textured bright pixels as barriers for flood-fill:
```python
is_textured_bright = is_textured & (mean_brightness > 200)
white_like = white_like & ~is_textured_bright
```
If scipy.ndimage is not available, implement the uniform filter manually with cumulative sums.

**Step 5 — Morphological cleanup on flood-fill result:**
After the BFS flood-fill completes (after line 264, before upscaling), apply morphological operations to the `visited` mask:
- Erosion (1-2px) to pull back the mask from product edges where flood-fill may have crept in slightly
- Then dilation (1-2px) to restore the mask to its original extent in areas that weren't near products
- This is effectively a morphological opening: removes thin flood-fill incursions into products while preserving the bulk background mask
Use `scipy.ndimage.binary_erosion` / `binary_dilation` or implement manually with NumPy. A simple approach:
```python
from scipy.ndimage import binary_erosion, binary_dilation
structure = np.ones((3, 3), dtype=bool)
visited = binary_erosion(visited, structure=structure, iterations=1)
visited = binary_dilation(visited, structure=structure, iterations=1)
```

**Step 6 — Add scipy import:**
Add `from scipy.ndimage import gaussian_filter, uniform_filter, binary_erosion, binary_dilation` at the top of the file (near the NumPy import on line 14). If scipy is already a dependency (check requirements.txt), great. If not, fall back to manual NumPy implementations (box blur via cumsum, manual erosion/dilation via shifts). Prefer scipy if available — this is an image processing project and scipy.ndimage is the standard tool.

**Backward compatibility:** All new barriers only activate on bright pixels (brightness > 200) with subtle signals. For standard images with dark/colorful products on white backgrounds, the gradient barrier and saturation/texture barriers won't fire on the product (which has brightness << 200), so behavior is identical. The morphological cleanup only removes thin incursions, not bulk background regions.

**IMPORTANT constraints per user decisions:**
- All processing at 256px downscaled resolution (where flood-fill operates)
- No changes to #F3F3F3 background color
- No artificial edge/shadow addition — just accurate masking
- Must not affect images that already work correctly
  </action>
  <verify>
Run a quick smoke test using the Natura Siberica test image:
```bash
cd /Users/marek/Desktop/Coding/image-procesor/image-procesor-repo
python3 -c "
from universal_processor import UniversalProcessor
from PIL import Image
import numpy as np

config = {
    'target_width': 800, 'target_height': 800,
    'background_color': '#F3F3F3',
    'ai_background_removal': False
}
proc = UniversalProcessor(config)
img = Image.open('/Users/marek/Downloads/unnamed (1) .webp')
if img.mode == 'RGBA':
    bg = Image.new('RGB', img.size, (255,255,255))
    bg.paste(img, mask=img.split()[3])
    img = bg
mask = proc._compute_background_mask_rgb(img)
product_mask = ~mask
# Count product pixels — should be substantial (not near-zero)
product_ratio = np.sum(product_mask) / product_mask.size
print(f'Product pixel ratio: {product_ratio:.4f}')
# Should be > 0.15 for an image with 3 products
assert product_ratio > 0.10, f'Product mask too small ({product_ratio:.4f}) — flood-fill likely bleeding into products'
print('PASS: Product mask has sufficient coverage')
"
```
Also verify no import errors and the method runs without exceptions.
  </verify>
  <done>
- `_compute_background_mask_rgb` has multi-signal edge barrier (gradient + saturation + texture)
- Morphological cleanup removes thin flood-fill incursions
- Gradient threshold lowered to 10
- Pre-smoothing applied before gradient computation
- Natura Siberica test image produces product mask with ratio > 0.10 (products not eaten)
- No import errors, method runs cleanly
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Visual verification of flood-fill fix</name>
  <files>universal_processor.py</files>
  <action>
Generate the test output image for human verification. Process the Natura Siberica test image in non-AI mode and save the result:
```bash
cd /Users/marek/Desktop/Coding/image-procesor/image-procesor-repo
python3 -c "
from universal_processor import UniversalProcessor
from PIL import Image

config = {
    'target_width': 800, 'target_height': 800,
    'background_color': '#F3F3F3',
    'ai_background_removal': False,
    'output_format': 'webp'
}
proc = UniversalProcessor(config)
img = Image.open('/Users/marek/Downloads/unnamed (1) .webp')
result = proc.process_image(img, 'natura_test')
result.save('/tmp/natura_flood_fill_test.webp', 'WEBP', quality=95)
print('Saved to /tmp/natura_flood_fill_test.webp')
"
```
Then pause for human visual inspection.

**What was built:**
Improved flood-fill edge barrier in `_compute_background_mask_rgb` with:
- Lower gradient threshold (10 vs 15)
- Pre-smoothing before gradient
- Saturation-based barrier (catches subtle product color vs neutral background)
- Local texture/variance barrier (catches product text/logos)
- Morphological cleanup on flood-fill mask

**How to verify — open `/tmp/natura_flood_fill_test.webp` and check:**
1. All 3 products visible (left white box, center tube, small right box)
2. White areas of the left box are intact (not eaten/transparent)
3. Products are visually distinct from the #F3F3F3 background (white product surfaces brighter than background)
4. No new artifacts (halos, rough edges, missing background areas)
5. If you have other standard product images, process one to verify backward compatibility
  </action>
  <verify>Human opens the output image and confirms all 3 products are visible and intact with no artifacts.</verify>
  <done>User types "approved" confirming all 3 products are visible with white areas intact and no regressions, or describes issues to fix.</done>
</task>

</tasks>

<verification>
Phase 1 is complete when:
1. Natura Siberica test image in non-AI mode shows all 3 products with white areas intact
2. Product pixel ratio from `_compute_background_mask_rgb` is > 0.10 for the test image
3. White product surfaces are visually brighter than #F3F3F3 background
4. No regressions on standard product images
</verification>

<success_criteria>
- PROC-01: Flood-fill does not bleed into white product areas touching the image edge (verified visually on Natura Siberica test image)
- PROC-02: White products are visually distinct from #F3F3F3 background (12-unit brightness difference preserved through accurate masking)
- Backward compatibility: Standard images process identically (no new barriers fire on dark/colorful products)
</success_criteria>

<output>
After completion, create `.planning/phases/01-flood-fill-fix/01-01-SUMMARY.md`
</output>
